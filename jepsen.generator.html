<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>jepsen.generator documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Jepsen</span> <span class="project-version">0.3.8</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jepsen</span></div></div></li><li class="depth-2 branch"><a href="jepsen.adya.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adya</span></div></a></li><li class="depth-2"><a href="jepsen.checker.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>checker</span></div></a></li><li class="depth-3 branch"><a href="jepsen.checker.clock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clock</span></div></a></li><li class="depth-3 branch"><a href="jepsen.checker.perf.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>perf</span></div></a></li><li class="depth-3"><a href="jepsen.checker.timeline.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timeline</span></div></a></li><li class="depth-2 branch"><a href="jepsen.cli.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>cli</span></div></a></li><li class="depth-2 branch"><a href="jepsen.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-2 branch"><a href="jepsen.codec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>codec</span></div></a></li><li class="depth-2"><a href="jepsen.control.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>control</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.clj-ssh.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clj-ssh</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.docker.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>docker</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.k8s.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>k8s</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.net.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>net</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.retry.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>retry</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.scp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scp</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.sshj.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sshj</span></div></a></li><li class="depth-3"><a href="jepsen.control.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2 branch"><a href="jepsen.core.html"><div class="inner"><span class="tree" style="top: -300px;"><span class="top" style="height: 309px;"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="jepsen.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="jepsen.faketime.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>faketime</span></div></a></li><li class="depth-2 branch"><a href="jepsen.fs-cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fs-cache</span></div></a></li><li class="depth-2 current"><a href="jepsen.generator.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generator</span></div></a></li><li class="depth-3 branch"><a href="jepsen.generator.context.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>context</span></div></a></li><li class="depth-3 branch"><a href="jepsen.generator.interpreter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interpreter</span></div></a></li><li class="depth-3 branch"><a href="jepsen.generator.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-3"><a href="jepsen.generator.translation-table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>translation-table</span></div></a></li><li class="depth-2 branch"><a href="jepsen.independent.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>independent</span></div></a></li><li class="depth-2 branch"><a href="jepsen.lazyfs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lazyfs</span></div></a></li><li class="depth-2"><a href="jepsen.nemesis.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nemesis</span></div></a></li><li class="depth-3 branch"><a href="jepsen.nemesis.combined.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>combined</span></div></a></li><li class="depth-3 branch"><a href="jepsen.nemesis.file.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>file</span></div></a></li><li class="depth-3"><a href="jepsen.nemesis.membership.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>membership</span></div></a></li><li class="depth-4"><a href="jepsen.nemesis.membership.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-3"><a href="jepsen.nemesis.time.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>time</span></div></a></li><li class="depth-2"><a href="jepsen.net.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>net</span></div></a></li><li class="depth-3"><a href="jepsen.net.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-2"><a href="jepsen.os.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>os</span></div></a></li><li class="depth-3 branch"><a href="jepsen.os.centos.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>centos</span></div></a></li><li class="depth-3 branch"><a href="jepsen.os.debian.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>debian</span></div></a></li><li class="depth-3 branch"><a href="jepsen.os.smartos.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>smartos</span></div></a></li><li class="depth-3"><a href="jepsen.os.ubuntu.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ubuntu</span></div></a></li><li class="depth-2 branch"><a href="jepsen.reconnect.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>reconnect</span></div></a></li><li class="depth-2 branch"><a href="jepsen.repl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>repl</span></div></a></li><li class="depth-2 branch"><a href="jepsen.report.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>report</span></div></a></li><li class="depth-2 branch"><a href="jepsen.role.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>role</span></div></a></li><li class="depth-2"><a href="jepsen.store.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>store</span></div></a></li><li class="depth-3 branch"><a href="jepsen.store.format.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>format</span></div></a></li><li class="depth-3"><a href="jepsen.store.fressian.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fressian</span></div></a></li><li class="depth-2"><a href="jepsen.tests.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>tests</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.adya.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adya</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.bank.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bank</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.causal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>causal</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.causal-reverse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>causal-reverse</span></div></a></li><li class="depth-3"><a href="jepsen.tests.cycle.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cycle</span></div></a></li><li class="depth-4 branch"><a href="jepsen.tests.cycle.append.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>append</span></div></a></li><li class="depth-4"><a href="jepsen.tests.cycle.wr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wr</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.kafka.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>kafka</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.linearizable-register.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linearizable-register</span></div></a></li><li class="depth-3"><a href="jepsen.tests.long-fork.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>long-fork</span></div></a></li><li class="depth-2 branch"><a href="jepsen.util.html"><div class="inner"><span class="tree" style="top: -331px;"><span class="top" style="height: 340px;"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="jepsen.web.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>web</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="jepsen.generator.html#var-all-processes"><div class="inner"><span>all-processes</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-all-threads"><div class="inner"><span>all-threads</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-any"><div class="inner"><span>any</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-clients"><div class="inner"><span>clients</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-concat"><div class="inner"><span>concat</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-concurrency-limit"><div class="inner"><span>concurrency-limit</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-context"><div class="inner"><span>context</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-cycle"><div class="inner"><span>cycle</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-cycle-times"><div class="inner"><span>cycle-times</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-delay"><div class="inner"><span>delay</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-dissoc-vec"><div class="inner"><span>dissoc-vec</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-each-process"><div class="inner"><span>each-process</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-each-thread"><div class="inner"><span>each-thread</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-each-thread-ensure-context-filters.21"><div class="inner"><span>each-thread-ensure-context-filters!</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-extend-protocol-runtime"><div class="inner"><span>extend-protocol-runtime</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-f-map"><div class="inner"><span>f-map</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-fill-in-op"><div class="inner"><span>fill-in-op</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-filter"><div class="inner"><span>filter</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-flip-flop"><div class="inner"><span>flip-flop</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-fn-wrapper"><div class="inner"><span>fn-wrapper</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-free-processes"><div class="inner"><span>free-processes</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-free-threads"><div class="inner"><span>free-threads</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-friendly-exceptions"><div class="inner"><span>friendly-exceptions</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-Generator"><div class="inner"><span>Generator</span></div></a></li><li class="depth-2 branch"><a href="jepsen.generator.html#var-op"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>op</span></div></a></li><li class="depth-2"><a href="jepsen.generator.html#var-update"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>update</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-init.21"><div class="inner"><span>init!</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-initialized.3F"><div class="inner"><span>initialized?</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-limit"><div class="inner"><span>limit</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-log"><div class="inner"><span>log</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-mix"><div class="inner"><span>mix</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-nemesis"><div class="inner"><span>nemesis</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-on"><div class="inner"><span>on</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-on-threads"><div class="inner"><span>on-threads</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-on-threads-context"><div class="inner"><span>on-threads-context</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-on-update"><div class="inner"><span>on-update</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-once"><div class="inner"><span>once</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-phases"><div class="inner"><span>phases</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-process-.3Ethread"><div class="inner"><span>process-&gt;thread</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-process-limit"><div class="inner"><span>process-limit</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-rand-int-seq"><div class="inner"><span>rand-int-seq</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-rand-seq"><div class="inner"><span>rand-seq</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-repeat"><div class="inner"><span>repeat</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-reserve"><div class="inner"><span>reserve</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-sleep"><div class="inner"><span>sleep</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-some-free-process"><div class="inner"><span>some-free-process</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-soonest-op-map"><div class="inner"><span>soonest-op-map</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-stagger"><div class="inner"><span>stagger</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-synchronize"><div class="inner"><span>synchronize</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-then"><div class="inner"><span>then</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-thread-.3Eprocess"><div class="inner"><span>thread-&gt;process</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-time-limit"><div class="inner"><span>time-limit</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-trace"><div class="inner"><span>trace</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-tracking-get.21"><div class="inner"><span>tracking-get!</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-until-ok"><div class="inner"><span>until-ok</span></div></a></li><li class="depth-1"><a href="jepsen.generator.html#var-validate"><div class="inner"><span>validate</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">jepsen.generator</h1><div class="doc"><div class="markdown"><h1><a href="#in-a-nutshell" id="in-a-nutshell"></a>In a Nutshell</h1>
<p>Generators tell Jepsen what to do during a test. Generators are purely functional objects which support two functions: <code>op</code> and <code>update</code>. <code>op</code> produces operations for Jepsen to perform: it takes a test and context object, and yields:</p>
<ul>
<li>nil if the generator is exhausted</li>
<li>:pending if the generator doesn’t know what to do yet</li>
<li><a href="op, gen'">op, gen’</a>, where op’ is the next operation this generator would like to execute, and <code>gen'</code> is the state of the generator that would result if <code>op</code> were evaluated. Ops must be a jepsen.history.Op.</li>
</ul>
<p><code>update</code> allows generators to evolve as events occur–for instance, when an operation is invoked or completed. For instance, <code>update</code> allows a generator to emit read operations <em>until</em> at least one succeeds.</p>
<p>Maps, sequences, and functions are all generators, allowing you to write all kinds of generators using existing Clojure tooling. This namespace provides additional transformations and combinators for complex transformations.</p>
<h1><a href="#migrating-from-classic-generators" id="migrating-from-classic-generators"></a>Migrating From Classic Generators</h1>
<p>The old jepsen.generator namespace used mutable state everywhere, and was plagued by race conditions. jepsen.generator.pure provides a similar API, but its purely functional approach has several advantages:</p>
<ul>
<li>
<p>Pure generators shouldn’t deadlock or throw weird interrupted exceptions. These issues have plagued classic generators; I’ve done my best to make incremental improvements, but the problems seem unavoidable.</p>
</li>
<li>
<p>Pure generators can respond to completion operations, which means you can write things like ‘keep trying x until y occurs’ without sharing complex mutable state with clients.</p>
</li>
<li>
<p>Sequences are pure generators out of the box; no more juggling gen/seq wrappers. Use existing Clojure sequence transformations to build complex behaviors.</p>
</li>
<li>
<p>Pure generators provide an explicit ‘I don’t know yet’ state, which is useful when you know future operations might come, but don’t know when or what they are.</p>
</li>
<li>
<p>Pure generators do not rely on dynamic state; their arguments are all explicit. They are deterministically testable.</p>
</li>
<li>
<p>Pure generators allow new combinators like (any gen1 gen2 gen3), which returns the first operation from any of several generators; this approach was impossible in classic generators.</p>
</li>
<li>
<p>Pure generators have an explicit, deterministic model of time, rather than relying on thread scheduler constructs like Thread/sleep.</p>
</li>
<li>
<p>Certain constructs, like gen/sleep and gen/log in classic generators, could not be composed in sequences readily; pure generators provide a regular composition language.</p>
</li>
<li>
<p>Constructs like gen/each, which were fragile in classic generators and relied on macro magic, are now simple functions.</p>
</li>
<li>
<p>Pure generators are significantly simpler to implement and test than classic generators, though they do require careful thought.</p>
</li>
</ul>
<p>There are some notable tradeoffs, including:</p>
<ul>
<li>
<p>Pure generators perform all generator-related computation on a single thread, and create additional garbage due to their pure functional approach. However, realistic generator tests yield rates over 20,000 operations/sec, which seems more than sufficient for Jepsen’s purposes.</p>
</li>
<li>
<p>The API is subtly different. In my experience teaching hundreds of engineers to write Jepsen tests, users typically cite the generator API as one of Jepsen’s best features. I’ve tried to preserve as much of its shape as possible, while sanding off rough edges and cleaning up inconsistencies. Some functions have the same shape but different semantics: <code>stagger</code>, for instance, now takes a <em>total</em> rather than a <code>*per-thread*</code> rate. Some infrequently-used generators have not been ported, to keep the API smaller.</p>
</li>
<li>
<p><code>update</code> and contexts are not a full replacement for mutable state. We think they should suffice for most practical uses, and controlled use of mutable shared state is still possible.</p>
</li>
<li>
<p>You can (and we encourage!) the use of impure functions, e.g. randomness, as impure generators. However, it’s possible I haven’t fully thought through the implications of this choice; the semantics may evolve over time.</p>
</li>
</ul>
<p>When migrating old to new generators, keep in mind:</p>
<ul>
<li>
<p><code>gen/seq</code> and <code>gen/seq-all</code> are unnecessary; any Clojure sequence is already a pure generator. <code>gen/seq</code> didn’t just turn sequences into generators; it also ensured that only one operation was consumed from each. This is now explicit: use <code>(map gen.pure/once coll)</code> instead of (gen/seq coll)<code>, and</code>coll<code>instead of</code>(gen/seq-all coll)<code>. Where the sequence is of one-shot generators already, there's no need to wrap elements with gen/once: instead of</code>(gen/seq <a href="{:f :read} {:f :write}">{:f :read} {:f :write}</a>)`), you can write <a href="{:f :read} {:f :write}">{:f :read} {:f :write}</a> directly.</p>
</li>
<li>
<p>Functions return generators, not just operations, which makes it easier to express sequences of operations like ‘pick the current leader, isolate it, then kill that same node, then restart that node.’ Use <code>#(gen/once {:f :write, :value (rand-int 5))</code> instead of <code>(fn [] {:f :write, :value (rand-int 5)})</code>.</p>
</li>
<li>
<p><code>stagger</code>, <code>delay</code>, etc. now take total rates, rather than the rate per thread.</p>
</li>
<li>
<p><code>delay-til</code> is gone. It should come back; I just haven’t written it yet. Defining what exactly delay-til means is… surprisingly tricky.</p>
</li>
<li>
<p><code>each</code> used to mean ‘on each process’, but in practice what users generally wanted was ‘on each thread’–on each process had a tendency to result in unexpected infinite loops when ops crashed. <code>each-thread</code> is probably what you want instead.</p>
</li>
<li>
<p>Instead of using <em>jepsen.generator/threads</em>, etc, use helper functions like some-free-process.</p>
</li>
<li>
<p>Functions now take zero args (f) or a test and context map (f test ctx), rather than (f test process).</p>
</li>
<li>
<p>Maps are one-shot generators by default, rather than emitting themselves indefinitely. This streamlines the most common use cases:</p>
<ul>
<li>
<p>(map (fn <a href="x">x</a> {:f :write, :value x}) (range)) produces a series of distinct, monotonically increasing writes</p>
</li>
<li>
<p>(fn [] {:f :inc, :value (rand-nth 5)}) produces a series of random increments, rather than a series where every value is the <em>same</em> (randomly selected) value.</p>
</li>
</ul>
</li>
</ul>
<p>When migrating, you can drop most uses of gen/once around maps, and introduce (repeat …) where you want to repeat an operation more than once.</p>
<h1><a href="#in-more-detail" id="in-more-detail"></a>In More Detail</h1>
<p>A Jepsen history is a list of operations–invocations and completions. A generator’s job is to specify what invocations to perform, and when. In a sense, a generator <em>becomes</em> a history as Jepsen incrementally applies it to a database.</p>
<p>Naively, we might define a history as a fixed sequence of invocations to perform at certain times, but this is impossible: we have only a fixed set of threads, and they may not be free to perform our operations. A thread must be <em>free</em> in order to perform an operation.</p>
<p>Time, too, is a dependency. When we schedule an operation to occur once per second, we mean that only once a certain time has passed can the next operation begin.</p>
<p>There may also be dependencies between threads. Perhaps only after a nemesis has initiated a network partition does our client perform a particular read. We want the ability to hold until a certain operation has begun.</p>
<p>Conceptually, then, a generator is a <em>graph</em> of events, some of which have not yet occurred. Some events are invocations: these are the operations the generator will provide to clients. Some events are completions: these are provided by clients to the generator. Other events are temporal: a certain time has passed.</p>
<p>This graph has some invocations which are <em>ready</em> to perform. When we have a ready invocation, we apply the invocation using the client, obtain a completion, and apply the completion back to the graph, obtaining a new graph.</p>
<h2><a href="#by-example" id="by-example"></a>By Example</h2>
<p>Perform a single read</p>
<p>{:f :read}</p>
<p>Perform a single random write:</p>
<p>(fn [] {:f :write, :value (rand-int 5))</p>
<p>Perform 10 random writes. This is regular clojure.core/repeat:</p>
<p>(repeat 10 (fn [] {:f :write, :value (rand-int 5)))</p>
<p>Perform a sequence of 50 unique writes. We use regular Clojure sequence functions here:</p>
<p>(-&gt;&gt; (range) (map (fn <a href="x">x</a> {:f :write, :value (rand-int 5)})) (take 50))</p>
<p>Write 3, then (possibly concurrently) read:</p>
<p><a href="{:f :write, :value 3} {:f :read}">{:f :write, :value 3} {:f :read}</a></p>
<p>Since these might execute concurrently, the read might not observe the write. To wait for the write to complete first:</p>
<p>(gen/phases {:f :write, :value 3} {:f :read})</p>
<p>Have each thread independently perform a single increment, then read:</p>
<p>(gen/each-thread <a href="{:f :inc} {:f :read}">{:f :inc} {:f :read}</a>)</p>
<p>Reserve 5 threads for reads, 10 threads for increments, and the remaining threads reset a counter.</p>
<p>(gen/reserve 5  (repeat {:f :read}) 10 (repeat {:f :inc}) (repeat {:f :reset}))</p>
<p>Perform a random mixture of unique writes and reads, randomly timed, at roughly 10 Hz, for 30 seconds:</p>
<p>(-&gt;&gt; (gen/mix [(repeat {:f :read}) (map (fn <a href="x">x</a> {:f :write, :value x}) (range))]) (gen/stagger 1/10) (gen/time-limit 30))</p>
<p>While that’s happening, have the nemesis alternate between breaking and repairing something roughly every 5 seconds:</p>
<p>(-&gt;&gt; (gen/mix [(repeat {:f :read}) (map (fn <a href="x">x</a> {:f :write, :value x}) (range))]) (gen/stagger 1/10) (gen/nemesis (-&gt;&gt; (cycle <a href="{:f :break}
{:f :repair}">{:f :break} {:f :repair}</a>) (gen/stagger 5))) (gen/time-limit 30))</p>
<p>Follow this by a single nemesis repair (along with an informational log message), wait 10 seconds for recovery, then have each thread perform reads until that thread sees at least one OK operation.</p>
<p>(gen/phases (-&gt;&gt; (gen/mix [(repeat {:f :read}) (map (fn <a href="x">x</a> {:f :write, :value x}) (range))]) (gen/stagger 1/10) (gen/nemesis (-&gt;&gt; (cycle <a href="{:f :break}
{:f :repair}">{:f :break} {:f :repair}</a>) (gen/stagger 5))) (gen/time-limit 30)) (gen/log “Recovering”) (gen/nemesis {:f :repair}) (gen/sleep 10) (gen/log “Final read”) (gen/clients (gen/each-thread (gen/until-ok {:f :read}))))</p>
<h2><a href="#contexts" id="contexts"></a>Contexts</h2>
<p>A <em>context</em> is a map which provides information about the state of the world to generators. For instance, a generator might need to know the number of threads which will ask it for operations. It can get that number from the <em>context</em>. Users can add their own values to the context map, which allows two generators to share state. When one generator calls another, it can pass a modified version of the context, which allows us to write generators that, say, run two independent workloads, each with their own concurrency and thread mappings.</p>
<p>The standard context mappings, which are provided by Jepsen when invoking the top-level generator, and can be expected by every generator, are defined in jepsen.generator.context. They include some stock fields:</p>
<pre><code>:time           The current Jepsen linear time, in nanoseconds
</code></pre>
<p>Additional fields (e.g. :threads, :free-threads, etc) are present for bookkeeping, but should not be interfered with or accessed directly: contexts are performance-sensitive and for optimization reasons their internal structure is somewhat complex. Use the functions <code>all-threads</code>, <code>thread-&gt;process</code>, <code>some-free-process</code>, etc. See jepsen.generator.context for these functions, which are also imported here in jepsen.generator.</p>
<h2><a href="#fetching-an-operation" id="fetching-an-operation"></a>Fetching an operation</h2>
<p>We use <code>(op gen test context)</code> to ask the generator for the next invocation that we can process.</p>
<p>The operation can have three forms:</p>
<ul>
<li>The generator may return <code>nil</code>, which means the generator is done, and there is nothing more to do. Once a generator does this, it must never return anything other than <code>nil</code>, even if the context changes.</li>
<li>The generator may return :pending, which means there might be more ops later, but it can’t tell yet.</li>
<li>The generator may return an operation, in which case:</li>
<li>If its time is in the past, we can evaluate it now</li>
<li>If its time is in the future, we wait until either:
<ul>
<li>The time arrives</li>
<li>Circumstances change (e.g. we update the generator)</li>
</ul>
</li>
</ul>
<p>But (op gen test context) returns more than just an operation; it also returns the <em>subsequent state</em> of the generator, if that operation were to be performed. The two are bundled into a tuple.</p>
<p>(op gen test context) =&gt; <a href="op gen'">op gen’</a>      ; known op <a href=":pending gen">:pending gen</a> ; unsure nil            ; exhausted</p>
<p>The analogous operations for sequences are (first) and (next); why do we couple them here? Why not use the update mechanism strictly to evolve state? Because the behavior in sequences is relatively simple: next always moves forward one item, whereas only <em>some</em> updates actually cause systems to move forward. Seqs always do the same thing in response to <code>next</code>, whereas generators may do different things depending on context. Moreover, Jepsen generators are often branched, rather than linearly wrapped, as sequences are, resulting in questions about <em>which branch</em> needs to be updated.</p>
<p>When I tried to strictly separate implementations of (op) and (update), it resulted in every update call attempting to determine whether this particular generator did or did not emit the given invocation event. This is <em>remarkably</em> tricky to do well, and winds up relying on all kinds of non-local assumptions about the behavior of the generators you wrap, and those which wrap you.</p>
<h2><a href="#updating-a-generator" id="updating-a-generator"></a>Updating a generator</h2>
<p>We still want the ability to respond to invocations and completions, e.g. by tracking that information in context variables. Therefore, in addition to (op) returning a new generator, we have a separate function, (update gen test context event), which allows generators to react to changing circumstances.</p>
<ul>
<li>We invoke an operation (e.g. one that the generator just gave us)</li>
<li>We complete an operation</li>
</ul>
<p>Updates use a context with a specific relationship to the event:</p>
<ul>
<li>The context :time is equal to the event :time</li>
<li>The free processes set reflects the state after the event has taken place; e.g. if the event is an invoke, the thread is listed as no longer free; if the event is a completion, the thread is listed as free.</li>
<li>The worker map reflects the process which that thread worker was executing at the time the event occurred.</li>
</ul>
<p>See jepsen.generator.context for more.</p>
<h2><a href="#default-implementations" id="default-implementations"></a>Default implementations</h2>
<p>Nil is a valid generator; it ignores updates and always yields nil for operations.</p>
<p>IPersistentMaps are generators which ignore updates and return exactly one operation which looks like the map itself, but with default values for time, process, and type provided based on the context. This means you can write a generator like</p>
<p>{:f :write, :value 2}</p>
<p>and it will generate a single op like</p>
<p>{:type :invoke, :process 3, :time 1234, :f :write, :value 2}</p>
<p>To produce an infinite series of ops drawn from the same map, use</p>
<p>(repeat {:f :write, :value 2}).</p>
<p>Sequences are generators which assume the elements of the sequence are themselves generators. They ignore updates, and return all operations from the first generator in the sequence, then all operations from the second, and so on.</p>
<p>Functions are generators which ignore updates and can take either test and context as arguments, or no args. Functions should be <em>mostly</em> pure, but some creative impurity is probably OK. For instance, returning randomized :values for maps is probably all right. I don’t know the laws! What is this, Haskell?</p>
<p>When a function is used as a generator, its return value is used as a generator; that generator is used until exhausted, and then the function is called again to produce a new generator. For instance:</p>
<p>; Produces a series of different random writes, e.g. 1, 5, 2, 3… (fn [] {:f :write, :value (rand-int 5)})</p>
<p>; Alternating write/read ops, e.g. write 2, read, write 5, read, … (fn [](map gen/once <a href="{:f :write, :value (rand-int 5)}
{:f :read}">{:f :write, :value (rand-int 5)} {:f :read}</a>))</p>
<p>Promises and delays are generators which ignore updates, yield :pending until realized, then are replaced by whatever generator they contain. Delays are not evaluated until they <em>could</em> produce an op, so you can include them in sequences, phases, etc., and they’ll be evaluated only once prior ops have been consumed.</p>
</div></div><div class="public anchor" id="var-all-processes"><h3>all-processes</h3><div class="usage"><code>(all-processes ctx)</code></div><div class="doc"><div class="markdown"><p>Given a context, returns a Bifurcan ISet of all processes currently belonging to some thread.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L49">view source</a></div></div><div class="public anchor" id="var-all-threads"><h3>all-threads</h3><div class="usage"><code>(all-threads ctx)</code></div><div class="doc"><div class="markdown"><p>Given a context, returns a Bifurcan ISet of all threads in it.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L49">view source</a></div></div><div class="public anchor" id="var-any"><h3>any</h3><div class="usage"><code>(any &amp; gens)</code></div><div class="doc"><div class="markdown"><p>Takes multiple generators and binds them together. Operations are taken from any generator. Updates are propagated to all generators.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L966">view source</a></div></div><div class="public anchor" id="var-clients"><h3>clients</h3><div class="usage"><code>(clients client-gen)</code><code>(clients client-gen nemesis-gen)</code></div><div class="doc"><div class="markdown"><p>In the single-arity form, wraps a generator such that only clients request operations from it. In its two-arity form, combines a generator of client operations and a generator for nemesis operations into one. When the process requesting an operation is :nemesis, routes to the nemesis generator; otherwise to the client generator.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1204">view source</a></div></div><div class="public anchor" id="var-concat"><h3>concat</h3><div class="usage"><code>(concat &amp; gens)</code></div><div class="doc"><div class="markdown"><p>Where your generators are sequences, you can use Clojure’s <code>concat</code> to make them a generator. This <code>concat</code> is useful when you’re trying to concatenate arbitrary generators. Right now, (concat a b c) is simply ’(a b c).</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L806">view source</a></div></div><div class="public anchor" id="var-concurrency-limit"><h3>concurrency-limit</h3><div class="usage"><code>(concurrency-limit n gen)</code></div><div class="doc"><div class="markdown"><p>Limits the number of concurrent operations performed by a generator to at most n. This generator returns :pending whenever there are n or more threads busy.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1391">view source</a></div></div><div class="public anchor" id="var-context"><h3>context</h3><div class="usage"><code>(context test)</code></div><div class="doc"><div class="markdown"><p>Constructs a fresh Context for a test. Its initial time is 0. Its threads are the integers from 0 to (:concurrency test), plus a :nemesis). Every thread is free. Each initially runs itself as a process.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L258">view source</a></div></div><div class="public anchor" id="var-cycle"><h3>cycle</h3><div class="usage"><code>(cycle gen)</code><code>(cycle limit gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a finite generator so that once it completes (e.g. emits nil), it begins again. With an optional integer limit, repeats the generator that many times. When the generator returns nil, it is reset to its original value and the cycle repeats. Updates are propagated to the current generator, but do not affect the original. Not sure if this is the right call–might change that later.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1338">view source</a></div></div><div class="public anchor" id="var-cycle-times"><h3>cycle-times</h3><div class="usage"><code>(cycle-times &amp; specs)</code></div><div class="doc"><div class="markdown"><p>Cycles between several generators on a rotating schedule. Takes a flat series of <a href="time, generator">time, generator</a> pairs, like so:</p>
<pre><code>(cycle-times 5  {:f :write}
             10 (gen/stagger 1 {:f :read}))
</code></pre>
<p>This generator emits writes for five seconds, then staggered reads for ten seconds, then goes back to writes, and so on. Generator state is preserved from cycle to cycle, which makes this suitable for e.g. interleaving quiet periods into a nemesis generator which needs to perform a specific sequence of operations like :add-node, :remove-node, :add-node …</p>
<p>Updates are propagated to all generators.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1684">view source</a></div></div><div class="public anchor" id="var-delay"><h3>delay</h3><div class="usage"><code>(delay dt gen)</code></div><div class="doc"><div class="markdown"><p>Given a time dt in seconds, and an underlying generator gen, constructs a generator which tries to emit operations exactly dt seconds apart. Emits operations more frequently if it falls behind. Like <code>stagger</code>, this should result in histories where operations happen roughly every dt seconds.</p>
<p>Note that this definition of delay differs from its stateful cousin delay, which a.) introduced dt seconds of delay between <em>completion</em> and subsequent invocation, and b.) emitted 1/dt ops/sec <em>per thread</em>, rather than globally.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1516">view source</a></div></div><div class="public anchor" id="var-dissoc-vec"><h3>dissoc-vec</h3><div class="usage"><code>(dissoc-vec v i)</code></div><div class="doc"><div class="markdown"><p>Cut a single index out of a vector, returning a vector one shorter, without the element at that index.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1228">view source</a></div></div><div class="public anchor" id="var-each-process"><h3>each-process</h3><div class="usage"><code>(each-process gen)</code></div><div class="doc"><div class="markdown"><p>Takes a generator. Constructs a generator which maintains independent copies of that generator for every process. Each generator sees exactly one thread &amp; process in its free process list. Updates are propagated to the generator for the thread which emitted the operation.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1100">view source</a></div></div><div class="public anchor" id="var-each-thread"><h3>each-thread</h3><div class="usage"><code>(each-thread gen)</code></div><div class="doc"><div class="markdown"><p>Takes a generator. Constructs a generator which maintains independent copies of that generator for every thread. Each generator sees exactly one thread in its free process list. Updates are propagated to the generator for the thread which emitted the operation.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1030">view source</a></div></div><div class="public anchor" id="var-each-thread-ensure-context-filters.21"><h3>each-thread-ensure-context-filters!</h3><div class="usage"><code>(each-thread-ensure-context-filters! context-filters ctx)</code></div><div class="doc"><div class="markdown"><p>Ensures an EachThread has context filters for each thread.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L975">view source</a></div></div><div class="public anchor" id="var-extend-protocol-runtime"><h3>extend-protocol-runtime</h3><h4 class="type">macro</h4><div class="usage"><code>(extend-protocol-runtime proto klass &amp; specs)</code></div><div class="doc"><div class="markdown"><p>Extends a protocol to a runtime-defined class. Helpful because some Clojure constructs, like promises, use reify rather than classes, and have no distinct interface we can extend.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L622">view source</a></div></div><div class="public anchor" id="var-f-map"><h3>f-map</h3><div class="usage"><code>(f-map f-map g)</code></div><div class="doc"><div class="markdown"><p>Takes a function <code>f-map</code> converting op functions (:f op) to other functions, and a generator <code>g</code>. Returns a generator like <code>g</code>, but where fs are replaced according to <code>f-map</code>. Useful for composing generators together for use with a composed nemesis.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L822">view source</a></div></div><div class="public anchor" id="var-fill-in-op"><h3>fill-in-op</h3><div class="usage"><code>(fill-in-op op ctx)</code></div><div class="doc"><div class="markdown"><p>Takes an operation as a map and fills in missing fields for :type, :process, and :time using context. Returns :pending if no process is free. Turns maps into history Ops.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L508">view source</a></div></div><div class="public anchor" id="var-filter"><h3>filter</h3><div class="usage"><code>(filter f gen)</code></div><div class="doc"><div class="markdown"><p>A generator which filters operations from an underlying generator, passing on only those which match (f op). Like <code>map</code>, :pending and nil operations bypass the filter.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L844">view source</a></div></div><div class="public anchor" id="var-flip-flop"><h3>flip-flop</h3><div class="usage"><code>(flip-flop a b)</code></div><div class="doc"><div class="markdown"><p>Emits an operation from generator A, then B, then A again, then B again, etc. Stops as soon as any gen is exhausted. Updates are ignored.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1612">view source</a></div></div><div class="public anchor" id="var-fn-wrapper"><h3>fn-wrapper</h3><div class="usage"><code>(fn-wrapper f)</code></div><div class="doc"><div class="markdown"><p>Wraps a function into a wrapper which makes it more efficient to invoke. We memoize the function’s arity, in particular, to reduce reflection.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L563">view source</a></div></div><div class="public anchor" id="var-free-processes"><h3>free-processes</h3><div class="usage"><code>(free-processes ctx)</code></div><div class="doc"><div class="markdown"><p>Given a context, returns a collection of processes which are not actively processing an invocation.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L49">view source</a></div></div><div class="public anchor" id="var-free-threads"><h3>free-threads</h3><div class="usage"><code>(free-threads ctx)</code></div><div class="doc"><div class="markdown"><p>Given a context, returns a Bifurcan ISet of threads which are not actively processing an invocation.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L49">view source</a></div></div><div class="public anchor" id="var-friendly-exceptions"><h3>friendly-exceptions</h3><div class="usage"><code>(friendly-exceptions gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator, so that exceptions thrown from op and update are wrapped with a :type ::op-threw or ::update-threw Slingshot exception map, including the generator, context, and event which caused the exception.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L744">view source</a></div></div><div class="public anchor" id="var-Generator"><h3>Generator</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-op"><h3>op</h3><div class="usage"><code>(op gen test context)</code></div><div class="doc"><div class="markdown"><p>Obtains the next operation from this generator. Returns an pair of <a href="op gen'">op gen’</a>, or <a href=":pending gen">:pending gen</a>, or nil if this generator is exhausted.</p>
</div></div></div><div class="public anchor" id="var-update"><h3>update</h3><div class="usage"><code>(update gen test context event)</code></div><div class="doc"><div class="markdown"><p>Updates the generator to reflect an event having taken place. Returns a generator (presumably, <code>gen</code>, perhaps with some changes) resulting from the update.</p>
</div></div></div></div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L408">view source</a></div></div><div class="public anchor" id="var-init.21"><h3>init!</h3><div class="usage"><code>(init!)</code></div><div class="doc"><div class="markdown"><p>We do some magic to extend the Generator protocol over promises etc, but it’s fragile and could break with… I think AOT compilation, but also apparently plain old dependencies? I’m not certain. It’s weird. Just to be safe, we move this into a function that gets called by jepsen.generator.interpreter, so that we observe the <em>real</em> version of the promise reify auto-generated class.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L633">view source</a></div></div><div class="public anchor" id="var-initialized.3F"><h3>initialized?</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L630">view source</a></div></div><div class="public anchor" id="var-limit"><h3>limit</h3><div class="usage"><code>(limit remaining gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator and ensures that it returns at most <code>limit</code> operations. Propagates every update to the underlying generator.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1278">view source</a></div></div><div class="public anchor" id="var-log"><h3>log</h3><div class="usage"><code>(log msg)</code></div><div class="doc"><div class="markdown"><p>A generator which, when asked for an operation, logs a message and yields nil. Occurs only once; use <code>repeat</code> to repeat.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1289">view source</a></div></div><div class="public anchor" id="var-map"><h3>map</h3><div class="usage"><code>(map f gen)</code></div><div class="doc"><div class="markdown"><p>A generator which wraps another generator g, transforming operations it generates with (f op). When the underlying generator yields :pending or nil, this generator does too, without calling <code>f</code>. Passes updates to underlying generator.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L813">view source</a></div></div><div class="public anchor" id="var-mix"><h3>mix</h3><div class="usage"><code>(mix gens)</code></div><div class="doc"><div class="markdown"><p>A random mixture of several generators. Takes a collection of generators and chooses between them uniformly. Ignores updates; some users create broad (hundreds of generators) mixes.</p>
<p>To be precise, a mix behaves like a sequence of one-time, randomly selected generators from the given collection. This is efficient and prevents multiple generators from competing for the next slot, making it hard to control the mixture of operations.</p>
<p>TODO: This can interact badly with generators that return :pending; gen/mix won’t let other generators (which could help us get unstuck!) advance. We should probably cycle on :pending.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1251">view source</a></div></div><div class="public anchor" id="var-nemesis"><h3>nemesis</h3><div class="usage"><code>(nemesis nemesis-gen)</code><code>(nemesis nemesis-gen client-gen)</code></div><div class="doc"><div class="markdown"><p>In the single-arity form, wraps a generator such that only the nemesis requests operations from it. In its two-arity form, combines a generator of client operations and a generator for nemesis operations into one. When the process requesting an operation is :nemesis, routes to the nemesis generator; otherwise to the client generator.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1216">view source</a></div></div><div class="public anchor" id="var-on"><h3>on</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>For backwards compatibility</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L901">view source</a></div></div><div class="public anchor" id="var-on-threads"><h3>on-threads</h3><div class="usage"><code>(on-threads f gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator, restricting threads which can use it to only those threads which satisfy (f thread). Alters the context passed to the underlying generator: it will only include free threads and workers satisfying f. Updates are passed on only when the thread performing the update matches f.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L893">view source</a></div></div><div class="public anchor" id="var-on-threads-context"><h3>on-threads-context</h3><div class="usage"><code>(on-threads-context f context)</code></div><div class="doc"><div class="markdown"><p>For backwards compatibility; filters a context to just threads matching (f thread). Use context/make-thread-filter for performance.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L876">view source</a></div></div><div class="public anchor" id="var-on-update"><h3>on-update</h3><div class="usage"><code>(on-update f gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator with an update handler function. When an update occurs, calls (f this test ctx event), and returns whatever f does–presumably, a new generator. Can also be helpful for side effects–for instance, to update some shared mutable state when an update occurs.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L868">view source</a></div></div><div class="public anchor" id="var-once"><h3>once</h3><div class="usage"><code>(once gen)</code></div><div class="doc"><div class="markdown"><p>Emits only a single item from the underlying generator.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1284">view source</a></div></div><div class="public anchor" id="var-phases"><h3>phases</h3><div class="usage"><code>(phases &amp; generators)</code></div><div class="doc"><div class="markdown"><p>Takes several generators, and constructs a generator which evaluates everything from the first generator, then everything from the second, and so on.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1552">view source</a></div></div><div class="public anchor" id="var-process-.3Ethread"><h3>process-&gt;thread</h3><div class="usage"><code>(process-&gt;thread ctx process)</code></div><div class="doc"><div class="markdown"><p>Given a process, looks up which thread is executing it.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L49">view source</a></div></div><div class="public anchor" id="var-process-limit"><h3>process-limit</h3><div class="usage"><code>(process-limit n gen)</code></div><div class="doc"><div class="markdown"><p>Takes a generator and returns a generator with bounded concurrency–it emits operations for up to n distinct processes, but no more.</p>
<p>Specifically, we track the set of all processes in a context’s <code>workers</code> map: the underlying generator can return operations only from contexts such that the union of all processes across all such contexts has cardinality at most <code>n</code>. Tracking the union of all <em>possible</em> processes, rather than just those processes actually performing operations, prevents the generator from “trickling” at the end of a test, i.e. letting only one or two processes continue to perform ops, rather than the full concurrency of the test.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1363">view source</a></div></div><div class="public anchor" id="var-rand-int-seq"><h3>rand-int-seq</h3><div class="usage"><code>(rand-int-seq)</code><code>(rand-int-seq seed)</code></div><div class="doc"><div class="markdown"><p>Generates a reproducible sequence of random longs, given a random seed. If seed is not provided, taken from (rand-int)).</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L479">view source</a></div></div><div class="public anchor" id="var-rand-seq"><h3>rand-seq</h3><div class="usage"><code>(rand-seq)</code><code>(rand-seq seed)</code></div><div class="doc"><div class="markdown"><p>Generates a reproducible sequence of random doubles, given a random seed. If seed is not provided, taken from (rand-int)</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L487">view source</a></div></div><div class="public anchor" id="var-repeat"><h3>repeat</h3><div class="usage"><code>(repeat gen)</code><code>(repeat limit gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator so that it emits operations infinitely, or, with an initial limit, up to <code>limit</code> times. Think of this as the inverse of <code>once</code>: where <code>once</code> takes a generator that emits many things and makes it emit one, this takes a generator that emits (presumably) one thing, and makes it emit many.</p>
<p>The state of the underlying generator is unchanged as <code>repeat</code> yields operations, but <code>repeat</code> does <em>not</em> memoize its results; repeating a nondeterministic generator results in a sequence of <em>different</em> operations.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1306">view source</a></div></div><div class="public anchor" id="var-reserve"><h3>reserve</h3><div class="usage"><code>(reserve &amp; args)</code></div><div class="doc"><div class="markdown"><p>Takes a series of count, generator pairs, and a final default generator.</p>
<p>(reserve 5 write 10 cas read)</p>
<p>The first 5 threads will call the <code>write</code> generator, the next 10 will emit CAS operations, and the remaining threads will perform reads. This is particularly useful when you want to ensure that two classes of operations have a chance to proceed concurrently–for instance, if writes begin blocking, you might like reads to proceed concurrently without every thread getting tied up in a write.</p>
<p>Each generator sees a context which only includes the worker threads which will execute that particular generator. Updates from a thread are propagated only to the generator which that thread executes.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1160">view source</a></div></div><div class="public anchor" id="var-sleep"><h3>sleep</h3><div class="usage"><code>(sleep dt)</code></div><div class="doc"><div class="markdown"><p>Emits exactly one special operation which causes its receiving process to do nothing for dt seconds. Use (repeat (sleep 10)) to sleep repeatedly.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1528">view source</a></div></div><div class="public anchor" id="var-some-free-process"><h3>some-free-process</h3><div class="usage"><code>(some-free-process ctx)</code></div><div class="doc"><div class="markdown"><p>Given a context, returns a random free process, or nil if all are busy.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L49">view source</a></div></div><div class="public anchor" id="var-soonest-op-map"><h3>soonest-op-map</h3><div class="usage"><code>(soonest-op-map)</code><code>(soonest-op-map m)</code><code>(soonest-op-map m1 m2)</code></div><div class="doc"><div class="markdown"><p>Takes a pair of maps wrapping operations. Each map has the following structure:</p>
<p>:op       An operation :weight   An optional integer weighting.</p>
<p>Returns whichever map has an operation which occurs sooner. If one map is nil, the other happens sooner. If one map’s op is :pending, the other happens sooner. If one op has a lower :time, it happens sooner. If the two ops have equal :times, resolves the tie randomly proportional to the two maps’ respective :weights. With weights 2 and 3, returns the first map 2/5 of the time, and the second 3/5 of the time.</p>
<p>The :weight of the returned map is the <em>sum</em> of both weights if their times are equal, which makes this function suitable for use in a reduction over many generators.</p>
<p>Why is this nondeterministic? Because we use this function to decide between several alternative generators, and always biasing towards an earlier or later generator could lead to starving some threads or generators.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L903">view source</a></div></div><div class="public anchor" id="var-stagger"><h3>stagger</h3><div class="usage"><code>(stagger dt gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator. Operations from that generator are scheduled at uniformly random intervals between 0 to 2 * (dt seconds).</p>
<p>Unlike Jepsen’s original version of <code>stagger</code>, this actually <em>means</em> ‘schedule at roughly every dt seconds’, rather than ‘introduce roughly dt seconds of latency between ops’, which makes this less sensitive to request latency variations.</p>
<p>Also note that unlike Jepsen’s original version of <code>stagger</code>, this delay applies to <em>all</em> operations, not to each thread independently. If your old stagger dt is 10, and your concurrency is 5, your new stagger dt should be 2.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1446">view source</a></div></div><div class="public anchor" id="var-synchronize"><h3>synchronize</h3><div class="usage"><code>(synchronize gen)</code></div><div class="doc"><div class="markdown"><p>Takes a generator, and waits for all workers to be free before it begins.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1547">view source</a></div></div><div class="public anchor" id="var-then"><h3>then</h3><div class="usage"><code>(then a b)</code></div><div class="doc"><div class="markdown"><p>Generator A, synchronize, then generator B. Note that this takes its arguments backwards: b comes before a. Why? Because it reads better in -&gt;&gt; composition. You can say:</p>
<pre><code>(-&gt;&gt; (fn [] {:f :write :value 2})
     (limit 3)
     (then (once {:f :read})))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1559">view source</a></div></div><div class="public anchor" id="var-thread-.3Eprocess"><h3>thread-&gt;process</h3><div class="usage"><code>(thread-&gt;process ctx thread)</code></div><div class="doc"><div class="markdown"><p>Given a thread, looks up which process it’s executing.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator/context.clj#L49">view source</a></div></div><div class="public anchor" id="var-time-limit"><h3>time-limit</h3><div class="usage"><code>(time-limit dt gen)</code></div><div class="doc"><div class="markdown"><p>Takes a time in seconds, and an underlying generator. Once this emits an operation (taken from that underlying generator), will only emit operations for dt seconds.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1417">view source</a></div></div><div class="public anchor" id="var-trace"><h3>trace</h3><div class="usage"><code>(trace k gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator, logging calls to op and update before passing them on to the underlying generator. Takes a key k, which is included in every log line.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L789">view source</a></div></div><div class="public anchor" id="var-tracking-get.21"><h3>tracking-get!</h3><div class="usage"><code>(tracking-get! read-keys m k not-found)</code></div><div class="doc"><div class="markdown"><p>Takes an ArrayList, a map, a key, and a not-found value. Reads key from map, returning it or not-found. Adds the key to the list if it was in the map. Yourkit led me down this path.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L497">view source</a></div></div><div class="public anchor" id="var-until-ok"><h3>until-ok</h3><div class="usage"><code>(until-ok gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator, yielding operations from it until one of those operations completes with :type :ok.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L1596">view source</a></div></div><div class="public anchor" id="var-validate"><h3>validate</h3><div class="usage"><code>(validate gen)</code></div><div class="doc"><div class="markdown"><p>Validates the well-formedness of operations emitted from the underlying generator.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/generator.clj#L703">view source</a></div></div></div></body></html>