<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>jepsen.tests.kafka documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Jepsen</span> <span class="project-version">0.3.8</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jepsen</span></div></div></li><li class="depth-2 branch"><a href="jepsen.adya.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adya</span></div></a></li><li class="depth-2"><a href="jepsen.checker.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>checker</span></div></a></li><li class="depth-3 branch"><a href="jepsen.checker.clock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clock</span></div></a></li><li class="depth-3 branch"><a href="jepsen.checker.perf.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>perf</span></div></a></li><li class="depth-3"><a href="jepsen.checker.timeline.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timeline</span></div></a></li><li class="depth-2 branch"><a href="jepsen.cli.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>cli</span></div></a></li><li class="depth-2 branch"><a href="jepsen.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-2 branch"><a href="jepsen.codec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>codec</span></div></a></li><li class="depth-2"><a href="jepsen.control.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>control</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.clj-ssh.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clj-ssh</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.docker.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>docker</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.k8s.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>k8s</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.net.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>net</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.retry.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>retry</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.scp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scp</span></div></a></li><li class="depth-3 branch"><a href="jepsen.control.sshj.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sshj</span></div></a></li><li class="depth-3"><a href="jepsen.control.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2 branch"><a href="jepsen.core.html"><div class="inner"><span class="tree" style="top: -300px;"><span class="top" style="height: 309px;"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="jepsen.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="jepsen.faketime.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>faketime</span></div></a></li><li class="depth-2 branch"><a href="jepsen.fs-cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fs-cache</span></div></a></li><li class="depth-2"><a href="jepsen.generator.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generator</span></div></a></li><li class="depth-3 branch"><a href="jepsen.generator.context.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>context</span></div></a></li><li class="depth-3 branch"><a href="jepsen.generator.interpreter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interpreter</span></div></a></li><li class="depth-3 branch"><a href="jepsen.generator.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-3"><a href="jepsen.generator.translation-table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>translation-table</span></div></a></li><li class="depth-2 branch"><a href="jepsen.independent.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>independent</span></div></a></li><li class="depth-2 branch"><a href="jepsen.lazyfs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lazyfs</span></div></a></li><li class="depth-2"><a href="jepsen.nemesis.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nemesis</span></div></a></li><li class="depth-3 branch"><a href="jepsen.nemesis.combined.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>combined</span></div></a></li><li class="depth-3 branch"><a href="jepsen.nemesis.file.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>file</span></div></a></li><li class="depth-3"><a href="jepsen.nemesis.membership.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>membership</span></div></a></li><li class="depth-4"><a href="jepsen.nemesis.membership.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-3"><a href="jepsen.nemesis.time.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>time</span></div></a></li><li class="depth-2"><a href="jepsen.net.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>net</span></div></a></li><li class="depth-3"><a href="jepsen.net.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-2"><a href="jepsen.os.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>os</span></div></a></li><li class="depth-3 branch"><a href="jepsen.os.centos.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>centos</span></div></a></li><li class="depth-3 branch"><a href="jepsen.os.debian.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>debian</span></div></a></li><li class="depth-3 branch"><a href="jepsen.os.smartos.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>smartos</span></div></a></li><li class="depth-3"><a href="jepsen.os.ubuntu.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ubuntu</span></div></a></li><li class="depth-2 branch"><a href="jepsen.reconnect.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>reconnect</span></div></a></li><li class="depth-2 branch"><a href="jepsen.repl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>repl</span></div></a></li><li class="depth-2 branch"><a href="jepsen.report.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>report</span></div></a></li><li class="depth-2 branch"><a href="jepsen.role.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>role</span></div></a></li><li class="depth-2"><a href="jepsen.store.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>store</span></div></a></li><li class="depth-3 branch"><a href="jepsen.store.format.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>format</span></div></a></li><li class="depth-3"><a href="jepsen.store.fressian.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fressian</span></div></a></li><li class="depth-2"><a href="jepsen.tests.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>tests</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.adya.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adya</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.bank.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bank</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.causal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>causal</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.causal-reverse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>causal-reverse</span></div></a></li><li class="depth-3"><a href="jepsen.tests.cycle.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cycle</span></div></a></li><li class="depth-4 branch"><a href="jepsen.tests.cycle.append.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>append</span></div></a></li><li class="depth-4"><a href="jepsen.tests.cycle.wr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wr</span></div></a></li><li class="depth-3 branch current"><a href="jepsen.tests.kafka.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>kafka</span></div></a></li><li class="depth-3 branch"><a href="jepsen.tests.linearizable-register.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linearizable-register</span></div></a></li><li class="depth-3"><a href="jepsen.tests.long-fork.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>long-fork</span></div></a></li><li class="depth-2 branch"><a href="jepsen.util.html"><div class="inner"><span class="tree" style="top: -331px;"><span class="top" style="height: 340px;"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="jepsen.web.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>web</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="jepsen.tests.kafka.html#var-allowed-error-types"><div class="inner"><span>allowed-error-types</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-analysis"><div class="inner"><span>analysis</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-around-key-offset"><div class="inner"><span>around-key-offset</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-around-key-value"><div class="inner"><span>around-key-value</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-around-some"><div class="inner"><span>around-some</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-assocv"><div class="inner"><span>assocv</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-checker"><div class="inner"><span>checker</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-condense-error"><div class="inner"><span>condense-error</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-consume-counts"><div class="inner"><span>consume-counts</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-crash-client-gen"><div class="inner"><span>crash-client-gen</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-cycles.21"><div class="inner"><span>cycles!</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-datafy-version-order-log"><div class="inner"><span>datafy-version-order-log</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-downsample-plot"><div class="inner"><span>downsample-plot</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-duplicate-cases"><div class="inner"><span>duplicate-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-final-polls"><div class="inner"><span>final-polls</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-firstv"><div class="inner"><span>firstv</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-g1a-cases"><div class="inner"><span>g1a-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-graph"><div class="inner"><span>graph</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-index-seq"><div class="inner"><span>index-seq</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-int-poll-skip.2Bnonmonotonic-cases"><div class="inner"><span>int-poll-skip+nonmonotonic-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-int-poll-skip.2Bnonmonotonic-cases-per-key"><div class="inner"><span>int-poll-skip+nonmonotonic-cases-per-key</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-int-send-skip.2Bnonmonotonic-cases"><div class="inner"><span>int-send-skip+nonmonotonic-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-interleave-subscribes"><div class="inner"><span>interleave-subscribes</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-key-order-viz"><div class="inner"><span>key-order-viz</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-log-.3Elast-index-.3Evalues"><div class="inner"><span>log-&gt;last-index-&gt;values</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-log-.3Evalue-.3Efirst-index"><div class="inner"><span>log-&gt;value-&gt;first-index</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-lost-write-cases"><div class="inner"><span>lost-write-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-mop-index"><div class="inner"><span>mop-index</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-must-have-committed.3F"><div class="inner"><span>must-have-committed?</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-nonmonotonic-send-cases"><div class="inner"><span>nonmonotonic-send-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-nth.2B"><div class="inner"><span>nth+</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-.3Emax-offsets"><div class="inner"><span>op-&gt;max-offsets</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-.3Emax-poll-offsets"><div class="inner"><span>op-&gt;max-poll-offsets</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-.3Emax-send-offsets"><div class="inner"><span>op-&gt;max-send-offsets</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-.3Ethread"><div class="inner"><span>op-&gt;thread</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-around-key-offset"><div class="inner"><span>op-around-key-offset</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-around-key-value"><div class="inner"><span>op-around-key-value</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-pairs"><div class="inner"><span>op-pairs</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-read-offsets"><div class="inner"><span>op-read-offsets</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-read-pairs"><div class="inner"><span>op-read-pairs</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-reads"><div class="inner"><span>op-reads</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-reads-helper"><div class="inner"><span>op-reads-helper</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-reads-index"><div class="inner"><span>op-reads-index</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-write-offsets"><div class="inner"><span>op-write-offsets</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-write-pairs"><div class="inner"><span>op-write-pairs</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-writes"><div class="inner"><span>op-writes</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-op-writes-helper"><div class="inner"><span>op-writes-helper</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-plot-bounds"><div class="inner"><span>plot-bounds</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-plot-realtime-lag.21"><div class="inner"><span>plot-realtime-lag!</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-plot-realtime-lags.21"><div class="inner"><span>plot-realtime-lags!</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-plot-unseen.21"><div class="inner"><span>plot-unseen!</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-poll-skip.2Bnonmonotonic-cases"><div class="inner"><span>poll-skip+nonmonotonic-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-poll-skip.2Bnonmonotonic-cases-per-process"><div class="inner"><span>poll-skip+nonmonotonic-cases-per-process</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-poll-unseen"><div class="inner"><span>poll-unseen</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-precommitted-read-cases"><div class="inner"><span>precommitted-read-cases</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-previous-value"><div class="inner"><span>previous-value</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-readers-of"><div class="inner"><span>readers-of</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-reads-by-type"><div class="inner"><span>reads-by-type</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-reads-of-key"><div class="inner"><span>reads-of-key</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-reads-of-key-offset"><div class="inner"><span>reads-of-key-offset</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-reads-of-key-value"><div class="inner"><span>reads-of-key-value</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-realtime-lag"><div class="inner"><span>realtime-lag</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-render-order-viz.21"><div class="inner"><span>render-order-viz!</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-secondv"><div class="inner"><span>secondv</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-stats-checker"><div class="inner"><span>stats-checker</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-strip-types"><div class="inner"><span>strip-types</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-tag-rw"><div class="inner"><span>tag-rw</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-track-key-offsets"><div class="inner"><span>track-key-offsets</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-txn-generator"><div class="inner"><span>txn-generator</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-unseen"><div class="inner"><span>unseen</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-version-orders"><div class="inner"><span>version-orders</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-version-orders-reduce-mop"><div class="inner"><span>version-orders-reduce-mop</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-version-orders-update-log"><div class="inner"><span>version-orders-update-log</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-workload"><div class="inner"><span>workload</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-worst-realtime-lag"><div class="inner"><span>worst-realtime-lag</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-wr-graph"><div class="inner"><span>wr-graph</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-writer-of"><div class="inner"><span>writer-of</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-writes-by-type"><div class="inner"><span>writes-by-type</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-writes-of-key"><div class="inner"><span>writes-of-key</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-writes-of-key-offset"><div class="inner"><span>writes-of-key-offset</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-writes-of-key-value"><div class="inner"><span>writes-of-key-value</span></div></a></li><li class="depth-1"><a href="jepsen.tests.kafka.html#var-ww-graph"><div class="inner"><span>ww-graph</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">jepsen.tests.kafka</h1><div class="doc"><div class="markdown"><p>This workload is intended for systems which behave like the popular Kafka queue. This includes Kafka itself, as well as compatible systems like Redpanda.</p>
<p>At the abstract level of this workload, these systems provide a set of totally-ordered append-only logs called <em>partitions</em>, each of which stores a single arbitrary (and, for our purposes, unique) <em>message</em> at a particular <em>offset</em> into the log. Partitions are grouped together into <em>topics</em>: each topic is therefore partially ordered.</p>
<p>Each client has a <em>producer</em> and a <em>consumer</em> aspect; in Kafka these are separate clients, but for Jepsen’s purposes we combine them. A producer can <em>send</em> a message to a topic-partition, which assigns it a unique, theoretically monotonically-increasing offset and saves it durably at that offset. A consumer can <em>subscribe</em> to a topic, in which case the system aautomatically assigns it any number of partitions in that topic–this assignment can change at any time. Consumers can also assign themselves specific partitions manually. When a consumer <em>polls</em>, it receives messages and their offsets from whatever topic-partitions it is currently assigned to, and advances its internal state so that the next poll (barring a change in assignment) receives the immediately following messages.</p>
<h2><a href="#operations" id="operations"></a>Operations</h2>
<p>To subscribe to a new set of topics, we issue an operation like:</p>
<p>{:f :subscribe, :value <a href="k1, k2, ...">k1, k2, …</a>}</p>
<p>or</p>
<p>{:f :assign, :value <a href="k1, k2, ...">k1, k2, …</a>}</p>
<p>… where k1, k2, etc denote specific partitions. For subscribe, we convert those partitions to the topics which contain them, and subscribe to those topics; the database then controls which specific partitions we get. Just like the Kafka client API, both subscribe and assign replace the current topics for the consumer.</p>
<p>Assign ops can also have a special key <code>:seek-to-beginning? true</code> which indicates that the client should seek to the beginning of all its partitions.</p>
<p>Reads and writes (and mixes thereof) are encoded as a vector of micro-operations:</p>
<p>{:f :poll, :value <a href="op1, op2, ...">op1, op2, …</a>} {:f :send, :value <a href="op1, op2, ...">op1, op2, …</a>} {:f :txn,  :value <a href="op1, op2, ...">op1, op2, …</a>}</p>
<p>Where :poll and :send denote transactions comprising only reads or writes, respectively, and :txn indicates a general-purpose transaction. Operations are of two forms:</p>
<p><a href=":send key value">:send key value</a></p>
<p>… instructs a client to append <code>value</code> to the integer <code>key</code>–which maps uniquely to a single topic and partition. These operations are returned as:</p>
<p>[:send key <a href="offset value">offset value</a>]</p>
<p>where offset is the returned offset of the write, if available, or <code>nil</code> if it is unknown (e.g. if the write times out).</p>
<p>Reads are invoked as:</p>
<p><a href=":poll">:poll</a></p>
<p>… which directs the client to perform a single <code>poll</code> operation on its consumer. The results of that poll are expanded to:</p>
<p>[:poll {key1 [<a href="offset1 value1">offset1 value1</a> <a href="offset2 value2">offset2 value2</a> …], key2 <a href="...">…</a>}]</p>
<p>Where key1, key2, etc are integer keys obtained from the topic-partitions returned by the call to poll, and the value for that key is a vector of <a href="offset value">offset value</a> pairs, corresponding to the offset of that message in that particular topic-partition, and the value of the message—presumably, whatever was written by <code>[:send key value]</code> earlier.</p>
<p>When polling <em>without</em> using assign, clients should call <code>.commitSync</code> before returning a completion operation.</p>
<p>Before a transaction completes, we commit its offsets.</p>
<p>All transactions may return an optional key :rebalance-log, which is a vector of rebalancing events (changes in assigned partitions) that occurred during the execution of that transaction. Each rebalance event is a map like:</p>
<p>{:keys <a href="k1 k2 ...">k1 k2 …</a>}</p>
<p>There may be more keys in this map; I can’t remember right now.</p>
<h2><a href="#topic-partition-mapping" id="topic-partition-mapping"></a>Topic-partition Mapping</h2>
<p>We identify topics and partitions using abstract integer <em>keys</em>, rather than explicit topics and partitions. The client is responsible for mapping these keys bijectively to topics and partitions.</p>
<h2><a href="#analysis" id="analysis"></a>Analysis</h2>
<p>From this history we can perform a number of analyses:</p>
<ol>
<li>
<p>For any observed value of a key, we check to make sure that its writer was either :ok or :info; if the writer :failed, we know this constitutes an aborted read.</p>
</li>
<li>
<p>We verify that all sends and polls agree on the value for a given key and offset. We do not require contiguity in offsets, because transactions add invisible messages which take up an offset slot but are not visible to the API. If we find divergence, we know that Kakfa disagreed about the value at some offset.</p>
</li>
</ol>
<p>Having verified that each <a href="key offset">key offset</a> pair uniquely identifies a single value, we eliminate the offsets altogether and perform the remainder of the analysis purely in terms of keys and values. We construct a graph where vertices are values, and an edge v1 -&gt; v2 means that v1 immediately precedes v2 in the offset order (ignoring gaps in the offsets, which we assume are due to transaction metadata messages).</p>
<ol>
<li>
<p>For each key, we take the highest observed offset, and then check that every :ok :send operation with an equal or lower offset was <em>also</em> read by at least one consumer. If we find one, we know a write was lost!</p>
</li>
<li>
<p>We build a dependency graph between pairs of transactions T1 and T2, where T1 != T2, like so:</p>
</li>
</ol>
<p>ww. T1 sent value v1 to key k, and T2 sent v2 to k, and o1 &lt; o2 in the version order for k.</p>
<p>wr. T1 sent v1 to k, and T2’s highest read of k was v1.</p>
<p>rw. T1’s highest read of key k was offset o1, and T2 sent offset o2 to k, and o1 &lt; o2 in the version order for k.</p>
<p>Our use of “highest offset” is intended to capture the fact that each poll operation observes a <em>range</em> of offsets, but in general those offsets could have been generated by <em>many</em> transactions. If we drew wr edges for every offset polled, we’d generate superfluous edges–all writers are already related via ww dependencies, so the final wr edge, plus those ww edges, captures those earlier read values.</p>
<p>We draw rw edges only for the final versions of each key observed by a transaction. If we drew rw edges for an earlier version, we would incorrectly be asserting that later transactions were <em>not</em> observed!</p>
<p>We perform cycle detection and categorization of anomalies from this graph using Elle.</p>
<ol>
<li>
<p>Internal Read Contiguity: Within a transaction, each pair of reads on the same key should be directly related in the version order. If we observe a gap (e.g. v1 &lt; … &lt; v2) that indicates this transaction skipped over some values. If we observe an inversion (e.g. v2 &lt; v1, or v2 &lt; … &lt; v1) then we know that the transaction observed an order which disagreed with the “true” order of the log.</p>
</li>
<li>
<p>Internal Write Contiguity: Gaps between sequential pairs of writes to the same key are detected via Elle as write cycles. Inversions are not, so we check for them explicitly: a transaction sends v1, then v2, but v2 &lt; v1 or v2 &lt; … v1 in the version order.</p>
</li>
<li>
<p>Intermediate reads? I assume these happen constantly, but are they supposed to? It’s not totally clear what this MEANS, but I think it might look like a transaction T1 which writes <a href="v1 v2 v3">v1 v2 v3</a> to k, and another T2 which polls k and observes any of v1, v2, or v3, but not <em>all</em> of them. This miiight be captured as a wr-rw cycle in some cases, but perhaps not all, since we’re only generating rw edges for final reads.</p>
</li>
<li>
<p>Precommitted reads. These occur when a transaction observes a value that it wrote. This is fine in most transaction systems, but illegal in Kafka, which assumes that consumers (running at read committed) <em>never</em> observe uncommitted records.</p>
</li>
</ol>
</div></div><div class="public anchor" id="var-allowed-error-types"><h3>allowed-error-types</h3><div class="usage"><code>(allowed-error-types test)</code></div><div class="doc"><div class="markdown"><p>Redpanda does a lot of <em>things</em> that are interesting to know about, but not necessarily bad or against-spec. For instance, g0 cycles are normal in the Kafka transactional model, and g1c is normal with wr-only edges at read-uncommitted but <em>not</em> with read-committed. This is a <em>very</em> ad-hoc attempt to encode that so that Jepsen’s valid/invalid results are somewhat meaningful.</p>
<p>Takes a test, and returns a set of keyword error types (e.g. :poll-skip) which this test considers allowable.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2432">view source</a></div></div><div class="public anchor" id="var-analysis"><h3>analysis</h3><div class="usage"><code>(analysis history)</code><code>(analysis history opts)</code></div><div class="doc"><div class="markdown"><p>Builds up intermediate data structures used to understand a history. Options include:</p>
<p>:directory - Used for generating output files :ww-deps   - Whether to perform write-write inference on the basis of log offsets.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2206">view source</a></div></div><div class="public anchor" id="var-around-key-offset"><h3>around-key-offset</h3><div class="usage"><code>(around-key-offset k offset history)</code><code>(around-key-offset k offset n history)</code></div><div class="doc"><div class="markdown"><p>Filters a history to just those operations around a given key and offset; trimming their mops to just those regions as well.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L691">view source</a></div></div><div class="public anchor" id="var-around-key-value"><h3>around-key-value</h3><div class="usage"><code>(around-key-value k value history)</code><code>(around-key-value k value n history)</code></div><div class="doc"><div class="markdown"><p>Filters a history to just those operations around a given key and value; trimming their mops to just those regions as well.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L743">view source</a></div></div><div class="public anchor" id="var-around-some"><h3>around-some</h3><div class="usage"><code>(around-some pred n coll)</code></div><div class="doc"><div class="markdown"><p>Clips a sequence to just those elements near a predicate. Takes a predicate, a range n, and a sequence xs. Returns the series of all x in xs such x is within n elements of some x’ matching predicate.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L699">view source</a></div></div><div class="public anchor" id="var-assocv"><h3>assocv</h3><div class="usage"><code>(assocv v i value)</code></div><div class="doc"><div class="markdown"><p>An assoc on vectors which allows you to assoc at arbitrary indexes, growing the vector as needed. When v is nil, constructs a fresh vector rather than a map.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L474">view source</a></div></div><div class="public anchor" id="var-checker"><h3>checker</h3><div class="usage"><code>(checker)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2465">view source</a></div></div><div class="public anchor" id="var-condense-error"><h3>condense-error</h3><div class="usage"><code>(condense-error test [type errs])</code></div><div class="doc"><div class="markdown"><p>Takes a test and a pair of an error type (e.g. :lost-write) and a seq of errors. Returns a pair of [type, {:count n, :errors <a href="...">…</a>}], which tries to show the most interesting or severe errors without making the pretty-printer dump out two gigabytes of EDN.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2400">view source</a></div></div><div class="public anchor" id="var-consume-counts"><h3>consume-counts</h3><div class="usage"><code>(consume-counts {:keys [history op-reads]})</code></div><div class="doc"><div class="markdown"><p>Kafka transactions are supposed to offer ‘exactly once’ processing: a transaction using the subscribe workflow should be able to consume an offset and send something to an output queue, and if this transaction is successful, it should happen at most once. It’s not exactly clear to me <em>how</em> these semantics are supposed to work–it’s clearly not once per consumer group, because we routinely see dups with only one consumer group. As a fallback, we look for single consumer per process, which should DEFINITELY hold, but… appears not to.</p>
<p>We verify this property by looking at all committed transactions which performed a poll while subscribed (not assigned!) and keeping track of the number of times each key and value is polled. Yields a map of keys to values to consumed counts, wherever that count is more than one.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1968">view source</a></div></div><div class="public anchor" id="var-crash-client-gen"><h3>crash-client-gen</h3><div class="usage"><code>(crash-client-gen opts)</code></div><div class="doc"><div class="markdown"><p>A generator which, if the test has :crash-clients? true, periodically emits an operation to crash a random client.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L463">view source</a></div></div><div class="public anchor" id="var-cycles.21"><h3>cycles!</h3><div class="usage"><code>(cycles! {:keys [history directory], :as analysis})</code></div><div class="doc"><div class="markdown"><p>Finds a map of cycle names to cyclic anomalies in a partial analysis.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2188">view source</a></div></div><div class="public anchor" id="var-datafy-version-order-log"><h3>datafy-version-order-log</h3><div class="usage"><code>(datafy-version-order-log m)</code></div><div class="doc"><div class="markdown"><p>Turns a bifurcan integer map of Bifurcan sets, and converts it to a vector of Clojure sets.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L885">view source</a></div></div><div class="public anchor" id="var-downsample-plot"><h3>downsample-plot</h3><div class="usage"><code>(downsample-plot points)</code></div><div class="doc"><div class="markdown"><p>Sometimes we wind up feeding absolutely huge plots to gnuplot, which chews up a lot of CPU time. We downsample these points, skipping points which are close in both x and y.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1555">view source</a></div></div><div class="public anchor" id="var-duplicate-cases"><h3>duplicate-cases</h3><div class="usage"><code>(duplicate-cases {:keys [version-orders]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and identifies cases where a single value appears at more than one offset in a key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1454">view source</a></div></div><div class="public anchor" id="var-final-polls"><h3>final-polls</h3><div class="usage"><code>(final-polls offsets)</code></div><div class="doc"><div class="markdown"><p>Takes an atom containing a map of keys to offsets. Constructs a generator which:</p>
<ol>
<li>
<p>Checks the topic-partition state from the admin API</p>
</li>
<li>
<p>Crashes the client, to force a fresh one to be opened, just in case there’s broken state inside the client.</p>
</li>
<li>
<p>Assigns the new client to poll every key, and seeks to the beginning</p>
</li>
<li>
<p>Polls repeatedly</p>
</li>
</ol>
<p>This process repeats every 10 seconds until polls have caught up to the offsets in the offsets atom.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L434">view source</a></div></div><div class="public anchor" id="var-firstv"><h3>firstv</h3><div class="usage"><code>(firstv v)</code></div><div class="doc"><div class="markdown"><p>First for vectors.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L266">view source</a></div></div><div class="public anchor" id="var-g1a-cases"><h3>g1a-cases</h3><div class="usage"><code>(g1a-cases {:keys [history writes-by-type writer-of op-reads]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and looks for aborted reads, where a known-failed write is nonetheless visible to a committed read. Returns a seq of error maps, or nil if none are found.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1000">view source</a></div></div><div class="public anchor" id="var-graph"><h3>graph</h3><div class="usage"><code>(graph analysis history)</code></div><div class="doc"><div class="markdown"><p>A combined Elle dependency graph between completion operations.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2179">view source</a></div></div><div class="public anchor" id="var-index-seq"><h3>index-seq</h3><div class="usage"><code>(index-seq xs)</code></div><div class="doc"><div class="markdown"><p>Takes a seq of distinct values, and returns a map of:</p>
<p>{:by-index    A vector of the sequence :by-value    A map of values to their indices in the vector.}</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L838">view source</a></div></div><div class="public anchor" id="var-int-poll-skip.2Bnonmonotonic-cases"><h3>int-poll-skip+nonmonotonic-cases</h3><div class="usage"><code>(int-poll-skip+nonmonotonic-cases {:keys [history version-orders op-reads]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and looks for cases where a single transaction contains:</p>
<p>{:skip          A pair of poll values which read the same key and skip over some part of the log which we know should exist. :nonmonotonic A pair of poll values which <em>contradict</em> the log order, or repeat the same value.}</p>
<p>When a transaction’s rebalance log includes a key which would otherwise be involved in one of these violations, we don’t report it as an error: we assume that rebalances invalidate any assumption of monotonically advancing offsets.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1197">view source</a></div></div><div class="public anchor" id="var-int-poll-skip.2Bnonmonotonic-cases-per-key"><h3>int-poll-skip+nonmonotonic-cases-per-key</h3><div class="usage"><code>(int-poll-skip+nonmonotonic-cases-per-key version-orders op rebalanced-keys errs [k vs])</code></div><div class="doc"><div class="markdown"><p>A reducer for int-poll-skip+nonmonotonic-cases. Takes version orders, an op, a rebalanced-keys set, a transient vector of error maps and a <a href="key, values">key, values</a> pair from (op-reads). Adds an error if we can find one in some key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1150">view source</a></div></div><div class="public anchor" id="var-int-send-skip.2Bnonmonotonic-cases"><h3>int-send-skip+nonmonotonic-cases</h3><div class="usage"><code>(int-send-skip+nonmonotonic-cases {:keys [history version-orders]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and looks for cases where a single transaction contains a pair of sends to the same key which:</p>
<p>{:skip          Skips over some indexes of the log :nonmonotonic  Go backwards (or stay in the same place) in the log}</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1229">view source</a></div></div><div class="public anchor" id="var-interleave-subscribes"><h3>interleave-subscribes</h3><div class="usage"><code>(interleave-subscribes opts txn-gen)</code></div><div class="doc"><div class="markdown"><p>Takes CLI options (:sub-p) and a txn generator. Keeps track of the keys flowing through it, interspersing occasional :subscribe or :assign operations for recently seen keys.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L248">view source</a></div></div><div class="public anchor" id="var-key-order-viz"><h3>key-order-viz</h3><div class="usage"><code>(key-order-viz k log history)</code></div><div class="doc"><div class="markdown"><p>Takes a key, a log for that key (a vector of offsets to sets of elements which were observed at that offset) and a history of ops relevant to that key. Constructs an XML structure visualizing all sends/polls of that log’s offsets.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1855">view source</a></div></div><div class="public anchor" id="var-log-.3Elast-index-.3Evalues"><h3>log-&gt;last-index-&gt;values</h3><div class="usage"><code>(log-&gt;last-index-&gt;values log)</code></div><div class="doc"><div class="markdown"><p>Takes a log: a vector of sets of read values for each offset in a partition, possibly including <code>nil</code>s. Returns a vector which takes indices (dense offsets) to sets of values whose <em>last</em> appearance was at that position.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L864">view source</a></div></div><div class="public anchor" id="var-log-.3Evalue-.3Efirst-index"><h3>log-&gt;value-&gt;first-index</h3><div class="usage"><code>(log-&gt;value-&gt;first-index log)</code></div><div class="doc"><div class="markdown"><p>Takes a log: a vector of sets of read values for each offset in a partition, possibly including <code>nil</code>s. Returns a map which takes a value to the index where it first appeared.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L847">view source</a></div></div><div class="public anchor" id="var-lost-write-cases"><h3>lost-write-cases</h3><div class="usage"><code>(lost-write-cases {:keys [history version-orders reads-by-type writer-of readers-of]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and looks for cases of lost write: where a write that we <em>should</em> have observed is somehow not observed. Of course we cannot expect to observe everything: for example, if we send a message to Redpanda at the end of a test, and don’t poll for it, there’s no chance of us seeing it at all! Or a poller could fall behind.</p>
<p>What we do instead is identify the highest read value for each key v_max, and then take the set of all values <em>prior</em> to it in the version order: surely, if we read v_max = 3, and the version order is <a href="1 2 3 4">1 2 3 4</a>, we should also have read 1 and 2.</p>
<p>It’s not <em>quite</em> this simple. If a message appears at multiple offsets, the version order will simply pick one for us, which leads to nondeterminism. If an offset has multiple messages, a successfully inserted message could appear <em>nowhere</em> in the version order.</p>
<p>To deal with this, we examine the raw logs for each key, and build two index structures. The first maps values to their earliest (index) appearance in the log: we use this to determine the highest index that must have been read. The second is a vector which maps indexes to sets of values whose <em>last</em> appearance in the log was at that index. We use this vector to identify which values ought to have been read.</p>
<p>Once we’ve derived the set of values we ought to have read for some key k, we run through each poll of k and cross off the values read. If there are any values left, they must be lost updates.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1044">view source</a></div></div><div class="public anchor" id="var-mop-index"><h3>mop-index</h3><div class="usage"><code>(mop-index op f k v)</code></div><div class="doc"><div class="markdown"><p>Takes an operation, a function f (:poll or :send), a key k, and a value v. Returns the index (0, 1, …) within that operation’s value which performed that poll or send, or nil if none could be found.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2058">view source</a></div></div><div class="public anchor" id="var-must-have-committed.3F"><h3>must-have-committed?</h3><div class="usage"><code>(must-have-committed? reads-by-type op)</code></div><div class="doc"><div class="markdown"><p>Takes a reads-by-type map and a (presumably :info) transaction which sent something. Returns true iff the transaction was :ok, or if it was :info and we can prove that some send from this transaction was read.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L787">view source</a></div></div><div class="public anchor" id="var-nonmonotonic-send-cases"><h3>nonmonotonic-send-cases</h3><div class="usage"><code>(nonmonotonic-send-cases {:keys [history by-process version-orders]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and checks each process’s operations sequentially, looking for cases where a single process’s sends to a given key go backwards relative to the version order.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1374">view source</a></div></div><div class="public anchor" id="var-nth.2B"><h3>nth+</h3><div class="usage"><code>(nth+ v i)</code></div><div class="doc"><div class="markdown"><p>Nth for vectors, but returns nil instead of out-of-bounds.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L487">view source</a></div></div><div class="public anchor" id="var-op-.3Emax-offsets"><h3>op-&gt;max-offsets</h3><div class="usage"><code>(op-&gt;max-offsets op)</code></div><div class="doc"><div class="markdown"><p>Takes an operation (presumably, an OK or info one) and returns a map of keys to the highest offsets interacted with, either via send or poll, in that op.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L317">view source</a></div></div><div class="public anchor" id="var-op-.3Emax-poll-offsets"><h3>op-&gt;max-poll-offsets</h3><div class="usage"><code>(op-&gt;max-poll-offsets {:keys [type f value]})</code></div><div class="doc"><div class="markdown"><p>Takes an operation and returns a map of keys to the highest offsets polled.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L276">view source</a></div></div><div class="public anchor" id="var-op-.3Emax-send-offsets"><h3>op-&gt;max-send-offsets</h3><div class="usage"><code>(op-&gt;max-send-offsets {:keys [type f value]})</code></div><div class="doc"><div class="markdown"><p>Takes an operation and returns a map of keys to the highest offsets sent.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L298">view source</a></div></div><div class="public anchor" id="var-op-.3Ethread"><h3>op-&gt;thread</h3><div class="usage"><code>(op-&gt;thread test op)</code></div><div class="doc"><div class="markdown"><p>Returns the thread which executed a given operation.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1774">view source</a></div></div><div class="public anchor" id="var-op-around-key-offset"><h3>op-around-key-offset</h3><div class="usage"><code>(op-around-key-offset k offset op)</code><code>(op-around-key-offset k offset n op)</code></div><div class="doc"><div class="markdown"><p>Takes an operation and returns that operation with its value trimmed so that any send/poll operations are constrained to just the given key, and values within n of the given offset. Returns nil if operation is not relevant.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L661">view source</a></div></div><div class="public anchor" id="var-op-around-key-value"><h3>op-around-key-value</h3><div class="usage"><code>(op-around-key-value k value op)</code><code>(op-around-key-value k value n op)</code></div><div class="doc"><div class="markdown"><p>Takes an operation and returns that operation with its value trimmed so that any send/poll operations are constrained to just the given key, and values within n of the given value. Returns nil if operation is not relevant.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L718">view source</a></div></div><div class="public anchor" id="var-op-pairs"><h3>op-pairs</h3><div class="usage"><code>(op-pairs op)</code></div><div class="doc"><div class="markdown"><p>Returns a map of keys to the sequence of all <a href="offset value">offset value</a> pairs either written or read for that key; writes first.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L597">view source</a></div></div><div class="public anchor" id="var-op-read-offsets"><h3>op-read-offsets</h3><div class="usage"><code>(op-read-offsets op)</code></div><div class="doc"><div class="markdown"><p>Returns a map of keys to the sequence of all offsets read for that key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L565">view source</a></div></div><div class="public anchor" id="var-op-read-pairs"><h3>op-read-pairs</h3><div class="usage"><code>(op-read-pairs op)</code></div><div class="doc"><div class="markdown"><p>Returns a map of keys to the sequence of all <a href="offset value">offset value</a> pairs read for that key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L559">view source</a></div></div><div class="public anchor" id="var-op-reads"><h3>op-reads</h3><div class="usage"><code>(op-reads op)</code></div><div class="doc"><div class="markdown"><p>Returns a map of keys to the sequence of all values read for that key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L570">view source</a></div></div><div class="public anchor" id="var-op-reads-helper"><h3>op-reads-helper</h3><div class="usage"><code>(op-reads-helper op f)</code></div><div class="doc"><div class="markdown"><p>Takes an operation and a function which takes an offset-value pair. Returns a map of keys read by this operation to the sequence of (f <a href="offset value">offset value</a>) read for that key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L532">view source</a></div></div><div class="public anchor" id="var-op-reads-index"><h3>op-reads-index</h3><div class="usage"><code>(op-reads-index history)</code></div><div class="doc"><div class="markdown"><p>We call op-reads a LOT. This takes a history and builds an efficient index, then returns a function (op-reads op) which works just like (op-reads op), but is memoized.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L575">view source</a></div></div><div class="public anchor" id="var-op-write-offsets"><h3>op-write-offsets</h3><div class="usage"><code>(op-write-offsets op)</code></div><div class="doc"><div class="markdown"><p>Returns a map of keys to the sequence of all offsets written to that key in an op.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L520">view source</a></div></div><div class="public anchor" id="var-op-write-pairs"><h3>op-write-pairs</h3><div class="usage"><code>(op-write-pairs op)</code></div><div class="doc"><div class="markdown"><p>Returns a map of keys to the sequence of all <a href="offset value">offset value</a> pairs written to that key in an op.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L526">view source</a></div></div><div class="public anchor" id="var-op-writes"><h3>op-writes</h3><div class="usage"><code>(op-writes op)</code></div><div class="doc"><div class="markdown"><p>Returns a map of keys to the sequence of all values written to that key in an op.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L514">view source</a></div></div><div class="public anchor" id="var-op-writes-helper"><h3>op-writes-helper</h3><div class="usage"><code>(op-writes-helper op f)</code></div><div class="doc"><div class="markdown"><p>Takes an operation and a function which takes an offset-value pair. Returns a map of keys written by this operation to the sequence of (f <a href="offset value">offset value</a>) sends for that key. Note that offset may be nil.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L493">view source</a></div></div><div class="public anchor" id="var-plot-bounds"><h3>plot-bounds</h3><div class="usage"><code>(plot-bounds points)</code></div><div class="doc"><div class="markdown"><p>Quickly determine {:min-x, :max-x, :min-y, :max-y} from a series of <a href="x y">x y</a> points. Nil if there are no points.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1534">view source</a></div></div><div class="public anchor" id="var-plot-realtime-lag.21"><h3>plot-realtime-lag!</h3><div class="usage"><code>(plot-realtime-lag! test lags {:keys [nemeses subdirectory filename group-fn group-name]})</code></div><div class="doc"><div class="markdown"><p>Takes a test, a collection of realtime lag measurements, and options (e.g. those to checker/check). Plots a graph file (realtime-lag.png) in the store directory</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1779">view source</a></div></div><div class="public anchor" id="var-plot-realtime-lags.21"><h3>plot-realtime-lags!</h3><div class="usage"><code>(plot-realtime-lags! {:keys [history], :as test} lags opts)</code></div><div class="doc"><div class="markdown"><p>Constructs realtime lag plots for all processes together, and then another broken out by process, and also by key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1816">view source</a></div></div><div class="public anchor" id="var-plot-unseen.21"><h3>plot-unseen!</h3><div class="usage"><code>(plot-unseen! test unseen {:keys [subdirectory]})</code></div><div class="doc"><div class="markdown"><p>Takes a test, a collection of unseen measurements, and options (e.g. those to checker/check). Plots a graph file (unseen.png) in the store directory.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1583">view source</a></div></div><div class="public anchor" id="var-poll-skip.2Bnonmonotonic-cases"><h3>poll-skip+nonmonotonic-cases</h3><div class="usage"><code>(poll-skip+nonmonotonic-cases {:keys [history by-process version-orders op-reads]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and checks each process’s operations sequentially, looking for cases where a single process either jumped backwards or skipped over some region of a topic-partition. Returns a task of a map:</p>
<p>{:nonmonotonic  Cases where a process started polling at or before a previous operation last left off :skip          Cases where two successive operations by a single process skipped over one or more values for some key.}</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1344">view source</a></div></div><div class="public anchor" id="var-poll-skip.2Bnonmonotonic-cases-per-process"><h3>poll-skip+nonmonotonic-cases-per-process</h3><div class="usage"><code>(poll-skip+nonmonotonic-cases-per-process version-orders op-reads ops)</code></div><div class="doc"><div class="markdown"><p>Per-process helper for poll-skip+nonmonotonic cases.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1266">view source</a></div></div><div class="public anchor" id="var-poll-unseen"><h3>poll-unseen</h3><div class="usage"><code>(poll-unseen gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator. Keeps track of every offset that is successfully sent, and every offset that’s successfully polled. When there’s a key that has some offsets which were sent but not polled, we consider that unseen. This generator occasionally rewrites assign/subscribe operations to try and catch up to unseen keys.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L376">view source</a></div></div><div class="public anchor" id="var-precommitted-read-cases"><h3>precommitted-read-cases</h3><div class="usage"><code>(precommitted-read-cases {:keys [history op-reads]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis with a history and looks for a transaction which observed its own writes. Returns a vector of error maps, or nil if none are found.</p>
<p>This is legal in most DBs, but in Kafka’s model, sent values are supposed to be invisible to <em>all</em> pollers until their producing txn commits.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1019">view source</a></div></div><div class="public anchor" id="var-previous-value"><h3>previous-value</h3><div class="usage"><code>(previous-value version-order v2)</code></div><div class="doc"><div class="markdown"><p>Takes a version order for a key and a value. Returns the previous value in the version order, or nil if either we don’t know v2’s index or v2 was the first value in the version order.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2049">view source</a></div></div><div class="public anchor" id="var-readers-of"><h3>readers-of</h3><div class="usage"><code>(readers-of history op-reads)</code></div><div class="doc"><div class="markdown"><p>Takes a history and an op-reads fn, and builds a map of keys to values to vectors of completion operations which observed those that value.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2034">view source</a></div></div><div class="public anchor" id="var-reads-by-type"><h3>reads-by-type</h3><div class="usage"><code>(reads-by-type history op-reads)</code></div><div class="doc"><div class="markdown"><p>Takes a history and an op-reads fn, and constructs a map of types (:ok, :info, :fail) to maps of keys to the set of all values which were read for that key. We use this to identify, for instance, the known-successful reads for some key as a part of finding lost updates.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L770">view source</a></div></div><div class="public anchor" id="var-reads-of-key"><h3>reads-of-key</h3><div class="usage"><code>(reads-of-key k history)</code><code>(reads-of-key k v history)</code></div><div class="doc"><div class="markdown"><p>Returns a seq of all operations which read the given key, and, optionally, read the given value.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L603">view source</a></div></div><div class="public anchor" id="var-reads-of-key-offset"><h3>reads-of-key-offset</h3><div class="usage"><code>(reads-of-key-offset k offset history)</code></div><div class="doc"><div class="markdown"><p>Returns a seq of all operations which read the given key and offset.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L631">view source</a></div></div><div class="public anchor" id="var-reads-of-key-value"><h3>reads-of-key-value</h3><div class="usage"><code>(reads-of-key-value k value history)</code></div><div class="doc"><div class="markdown"><p>Returns a seq of all operations which read the given key and value.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L647">view source</a></div></div><div class="public anchor" id="var-realtime-lag"><h3>realtime-lag</h3><div class="usage"><code>(realtime-lag history)</code></div><div class="doc"><div class="markdown"><p>Takes a history and yields a series of maps of the form</p>
<p>{:process The process performing a poll :key     The key being polled :time    The time the read began, in nanos :lag     The realtime lag of this key, in nanos.</p>
<p>The lag of a key k in a poll is the conservative estimate of how long it has been since the highest value in that poll was the final message in log k.</p>
<p>For instance, given:</p>
<p>{:time 1, :type :ok, :value [:send :x <a href="0 :a">0 :a</a>]} {:time 2, :type :ok, :value [:poll {:x <a href="0 :a">0 :a</a>}]}</p>
<p>The lag of this poll is zero, since we observed the most recent completed write to x. However, if we:</p>
<p>{:time 3, :type :ok,      :value [:send :x <a href="1 :b">1 :b</a>]} {:time 4, :type :invoke,  :value <a href=":poll">:poll</a>} {:time 5, :type :ok,      :value [:poll {:x []}]}</p>
<p>The lag of this read is 4 - 3 = 1. By time 3, offset 1 must have existed for key x. However, the most recent offset we observed was 0, which could only have been the most recent offset up until the write of offset 1 at time 3. Since our read could have occurred as early as time 4, the lag is at least 1.</p>
<p>Might want to make this into actual <a href="lower upper">lower upper</a> ranges, rather than just the lower bound on lag, but conservative feels OK for starters.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1638">view source</a></div></div><div class="public anchor" id="var-render-order-viz.21"><h3>render-order-viz!</h3><div class="usage"><code>(render-order-viz! test {:keys [version-orders errors history], :as analysis})</code></div><div class="doc"><div class="markdown"><p>Takes a test, an analysis, and for each key with certain errors renders an HTML timeline of how each operation perceived that key’s log.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1942">view source</a></div></div><div class="public anchor" id="var-secondv"><h3>secondv</h3><div class="usage"><code>(secondv v)</code></div><div class="doc"><div class="markdown"><p>Second for vectors.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L271">view source</a></div></div><div class="public anchor" id="var-stats-checker"><h3>stats-checker</h3><div class="usage"><code>(stats-checker)</code><code>(stats-checker c)</code></div><div class="doc"><div class="markdown"><p>Wraps a (jepsen.checker/stats) with a new checker that returns the same results, except it won’t return :valid? false if :crash or :debug-topic-partitions ops always crash. You might want to wrap your existing stats checker with this.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2520">view source</a></div></div><div class="public anchor" id="var-strip-types"><h3>strip-types</h3><div class="usage"><code>(strip-types ms)</code></div><div class="doc"><div class="markdown"><p>Takes a collection of maps, and removes their :type fields. Returns nil if none remain.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1144">view source</a></div></div><div class="public anchor" id="var-tag-rw"><h3>tag-rw</h3><div class="usage"><code>(tag-rw gen)</code></div><div class="doc"><div class="markdown"><p>Takes a generator and tags operations as :f :poll or :send if they’re entirely comprised of send/polls.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L255">view source</a></div></div><div class="public anchor" id="var-track-key-offsets"><h3>track-key-offsets</h3><div class="usage"><code>(track-key-offsets keys-atom gen)</code></div><div class="doc"><div class="markdown"><p>Wraps a generator. Keeps track of every key that generator touches in the given atom, which is a map of keys to highest offsets seen.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L401">view source</a></div></div><div class="public anchor" id="var-txn-generator"><h3>txn-generator</h3><div class="usage"><code>(txn-generator la-gen)</code></div><div class="doc"><div class="markdown"><p>Takes a list-append generator and rewrites its transactions to be <a href=":poll">:poll</a> or <a href=":send k v">:send k v</a> micro-ops. Also adds a :keys field onto each operation, with a set of keys that txn would have interacted with; we use this to generate :subscribe ops later.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L209">view source</a></div></div><div class="public anchor" id="var-unseen"><h3>unseen</h3><div class="usage"><code>(unseen {:keys [history op-reads]})</code></div><div class="doc"><div class="markdown"><p>Takes a partial analysis and yields a series of maps like</p>
<p>{:time    The time in nanoseconds :unseen  A map of keys to the number of messages in that key which have been successfully acknowledged, but not polled by any client.}</p>
<p>The final map in the series includes a :messages key: a map of keys to sets of messages that were unseen.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1481">view source</a></div></div><div class="public anchor" id="var-version-orders"><h3>version-orders</h3><div class="usage"><code>(version-orders history reads-by-type)</code></div><div class="doc"><div class="markdown"><p>Takes a history and a reads-by-type structure. Constructs a map of:</p>
<p>{:orders   A map of keys to orders for that key. Each order is a map of: {:by-index        A vector which maps indices to single values, in log order. :by-value        A map of values to indices in the log. :log             A vector which maps offsets to sets of values in log order.}</p>
<p>:errors   A series of error maps describing any incompatible orders, where a single offset for a key maps to multiple values.}</p>
<p>Offsets are directly from Kafka. Indices are <em>dense</em> offsets, removing gaps in the log.</p>
<p>Note that we infer version orders from sends only when we can prove their effects were visible, but from <em>all</em> polls, including :info and :fail ones. Why? Because unlike a traditional transaction, where you shouldn’t trust reads in aborted txns, pollers in Kafka’s transaction design are <em>always</em> supposed to emit safe data regardless of whether the transaction commits or not.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L907">view source</a></div></div><div class="public anchor" id="var-version-orders-reduce-mop"><h3>version-orders-reduce-mop</h3><div class="usage"><code>(version-orders-reduce-mop logs mop)</code></div><div class="doc"><div class="markdown"><p>Takes a logs object from version-orders and a micro-op, and integrates that micro-op’s information about offsets into the logs.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L811">view source</a></div></div><div class="public anchor" id="var-version-orders-update-log"><h3>version-orders-update-log</h3><div class="usage"><code>(version-orders-update-log log offset value)</code></div><div class="doc"><div class="markdown"><p>Updates a version orders log with the given offset and value.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L800">view source</a></div></div><div class="public anchor" id="var-workload"><h3>workload</h3><div class="usage"><code>(workload opts)</code></div><div class="doc"><div class="markdown"><p>Constructs a workload (a map with a generator, client, checker, etc) given an options map. Options are:</p>
<p>:crash-clients? If set, periodically emits a :crash operation which the client responds to with :info; this forces the client to be torn down and replaced by a fresh client.</p>
<p>:crash-client-interval How often, in seconds, to crash clients. Default is 30 seconds.</p>
<p>:sub-via        A set of subscription methods: either #{:assign} or #{:subscribe}.</p>
<p>:txn?           If set, generates transactions with multiple send/poll micro-operations.</p>
<p>:sub-p          The probability that the generator emits an assign/subscribe op.</p>
<p>These options must also be present in the test map, because they are used by the checker, client, etc at various points. For your convenience, they are included in the workload map returned from this function; merging that map into your test should do the trick.</p>
<p>… plus those taken by jepsen.tests.cycle.append/test, e.g. :key-count, :min-txn-length, …</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2537">view source</a></div></div><div class="public anchor" id="var-worst-realtime-lag"><h3>worst-realtime-lag</h3><div class="usage"><code>(worst-realtime-lag lags)</code></div><div class="doc"><div class="markdown"><p>Takes a seq of realtime lag measurements, and finds the point with the highest lag.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L1849">view source</a></div></div><div class="public anchor" id="var-wr-graph"><h3>wr-graph</h3><div class="usage"><code>(wr-graph {:keys [writer-of readers-of op-reads]} history)</code></div><div class="doc"><div class="markdown"><p>Analyzes a history to extract write-read dependencies. T1 &lt; T2 iff T1 writes some v to k and T2 reads k.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2156">view source</a></div></div><div class="public anchor" id="var-writer-of"><h3>writer-of</h3><div class="usage"><code>(writer-of history)</code></div><div class="doc"><div class="markdown"><p>Takes a history and builds a map of keys to values to the completion operation which attempted to write that value.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2021">view source</a></div></div><div class="public anchor" id="var-writes-by-type"><h3>writes-by-type</h3><div class="usage"><code>(writes-by-type history)</code></div><div class="doc"><div class="markdown"><p>Takes a history and constructs a map of types (:ok, :info, :fail) to maps of keys to the set of all values which were written for that key. We use this to identify, for instance, what all the known-failed writes were for a given key.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L751">view source</a></div></div><div class="public anchor" id="var-writes-of-key"><h3>writes-of-key</h3><div class="usage"><code>(writes-of-key k history)</code><code>(writes-of-key k v history)</code></div><div class="doc"><div class="markdown"><p>Returns a seq of all operations which wrote the given key, and, optionally, sent the given value.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L617">view source</a></div></div><div class="public anchor" id="var-writes-of-key-offset"><h3>writes-of-key-offset</h3><div class="usage"><code>(writes-of-key-offset k offset history)</code></div><div class="doc"><div class="markdown"><p>Returns a seq of all operations which wrote the given key and offset.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L639">view source</a></div></div><div class="public anchor" id="var-writes-of-key-value"><h3>writes-of-key-value</h3><div class="usage"><code>(writes-of-key-value k value history)</code></div><div class="doc"><div class="markdown"><p>Returns a seq of all operations which wrote the given key and value.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L654">view source</a></div></div><div class="public anchor" id="var-ww-graph"><h3>ww-graph</h3><div class="usage"><code>(ww-graph {:keys [writer-of version-orders ww-deps]} history)</code></div><div class="doc"><div class="markdown"><p>Analyzes a history to extract write-write dependencies. T1 &lt; T2 iff T1 sends some v1 to k and T2 sends some v2 to k and v1 &lt; v2 in the version order.</p>
</div></div><div class="src-link"><a href="https://github.com/jepsen-io/jepsen/blob/v0.3.8/jepsen/src/jepsen/tests/kafka.clj#L2109">view source</a></div></div></div></body></html>